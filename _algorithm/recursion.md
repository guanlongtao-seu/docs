# 递归

> 当一个函数用它自己来定义时就称为是**递归(recursive)**的。

# 初识递归

##### 递归的基本法则
当编写递归程序时，关键是要牢记递归的**四条基本**法则:

  1.**基准情形 (base case)**。必须总要有某些基准情形，它无需递归就可以解出。
  
  2.**不断推进 (making progress)**。对于那些需要递归的求解的情形，每一次递归调用都必须要使情况朝向一种基准情形推进。
  
  3.**设计法则 (design rule)**。假设所有的递归调用都能运行。
  
  4.**合成法则 (compound interest rule)**。在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。  
  
使用递归计算诸如斐波那契数之类简单数学函数的值的想法一般来说不是一个好主意，其道理正是根据第四条法则。 

##### 递归与数学归纳法

* **数学归纳法的思想**

    一般地，证明一个与自然数 n 有关的命题`P(n)`，有如下步骤:

    (1) 证明当 n 取第一个值 n<sub>0</sub> 时命题成立;

    (2) 假设当 n=k(k⩾n<sub>0</sub>)时命题成立，证明当 n=k+1 时命题也成立。

    综合(1)(2)，对一切的自然数 n(n ⩾ n<sub>0</sub>)，命题`P(n)`都成立。

    其实，数学归纳法利用的是递推的原理，可以形象地叫做**多米诺原理**。 数学归纳法的关键就是**如何证明当 n = k + 1 时命题也成立**。

* **递归的思想**
    很明显，递归也是用了递推的思想。

    (1) 首先，我们需要一个递归的出口，即 base case;

    (2) 其次，是递归体的设计，即对于一个一般的情况如何向 base case 靠近，把它化解成为一个更小的，同样结构的问题。

    递归的关键就是**将问题转化成一个更小规模的同样结构的问题**。
    
##### 递归的经典例子

* **n! 的递归算法**

    求解 n! 是最经典入门的递归算法。根据前面的知识我们知道用递归解决这个问题，需要两个要点。
    
    首先，如何将一个大的问题转化成一个小规模的问题?我们知道，n! = n(n − 1)!， 
    那么根据这个公式，我们就可以轻易地将求解 n! 
    转化为求解 (n − 1)!(将问题的规模变小了，并且是同样的问题)。
    
    其次，如何找到 base case，即递归的出口呢?在该问题里面也是很明显的，最后求 1! 时，就不需要在递归了。所以，该递归算法可以写为:
    
    ```javascript
    const factorial = function(n){
          if (n === 1)
              return 1; // base case
          return n * factorial(n - 1); // making progress
    }
    ```

* **汉诺塔递归算法**

    如下图所示，从左到右 A、B、C 三根柱子，其中 A 柱子上面有从小叠到大的 n 个圆盘。 
    现要求将 A 柱子上的圆盘移到 C 柱子上去，期间只有一个原则:一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。
    
    <img src="_media/hanoi-tower.png">
    
    * 算法分析
    
    当 A 柱子上只有一个盘子时，可以直接把盘子移到 C 柱子上;
    当 A 柱子上有两个盘子时，需要借助 B 盘子，先将上面的小盘子移到 B 柱子上，再将大盘子移到 C 柱子上，再将小盘子移到 C 柱子上。
    那对于更一般的情况，当有 n 个盘子的时候怎么递归呢?当有 n 个盘子时，我们可以将盘子看成两个部分。第 n 个盘子和上面 n − 1 个盘子，
    如图中的颜色区分。就像是操作两个盘子(把前 n − 1 个盘子看成一个整体)：先把前 n − 1 个盘子从 A 盘放到 B 盘，再把第 n 个盘子从 A 盘放到 C 盘，
    最后再把前 n − 1 个 盘子从 B 盘放到 C 盘。这样我们就把问题的规模缩小到 n − 1 了。
