# 递归

> 当一个函数用它自己来定义时就称为是 **递归(recursive)** 的。

# 初识递归

##### 递归的基本法则
当编写递归程序时，关键是要牢记递归的**四条基本**法则:

  1. **基准情形 (base case)** 。必须总要有某些基准情形，它无需递归就可以解出。
  
  2. **不断推进 (making progress)** 。对于那些需要递归的求解的情形，每一次递归调用都必须要使情况朝向一种基准情形推进。
  
  3. **设计法则 (design rule)** 。假设所有的递归调用都能运行。
  
  4. **合成法则 (compound interest rule)** 。在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。  
  
使用递归计算诸如斐波那契数之类简单数学函数的值的想法一般来说不是一个好主意，其道理正是根据第四条法则。 

##### 递归与数学归纳法

* **数学归纳法的思想**

    一般地，证明一个与自然数 n 有关的命题`P(n)`，有如下步骤:

    (1) 证明当 n 取第一个值 n<sub>0</sub> 时命题成立;

    (2) 假设当 n=k(k⩾n<sub>0</sub>)时命题成立，证明当 n=k+1 时命题也成立。

    综合(1)(2)，对一切的自然数 n(n ⩾ n<sub>0</sub>)，命题`P(n)`都成立。

    其实，数学归纳法利用的是递推的原理，可以形象地叫做**多米诺原理**。 数学归纳法的关键就是**如何证明当 n = k + 1 时命题也成立**。

* **递归的思想**

    很明显，递归也是用了递推的思想。

    (1) 首先，我们需要一个递归的出口，即 base case;

    (2) 其次，是递归体的设计，即对于一个一般的情况如何向 base case 靠近，把它化解成为一个更小的，同样结构的问题。

    递归的关键就是**将问题转化成一个更小规模的同样结构的问题**。
    
##### 递归的经典例子

* **n! 的递归算法**

    求解 n! 是最经典入门的递归算法。根据前面的知识我们知道用递归解决这个问题，需要两个要点。
    
    首先，如何将一个大的问题转化成一个小规模的问题?我们知道，n! = n(n − 1)!， 
    那么根据这个公式，我们就可以轻易地将求解 n! 
    转化为求解 (n − 1)!(将问题的规模变小了，并且是同样的问题)。
    
    其次，如何找到 base case，即递归的出口呢?在该问题里面也是很明显的，最后求 1! 时，就不需要在递归了。所以，该递归算法可以写为:
    
    ```javascript
    const factorial = function(n){
          if (n === 1)
              return 1; // base case
          return n * factorial(n - 1); // making progress
    }
    ```

* **汉诺塔递归算法**

    如下图所示，从左到右 A、B、C 三根柱子，其中 A 柱子上面有从小叠到大的 n 个圆盘。 
    现要求将 A 柱子上的圆盘移到 C 柱子上去，期间只有一个原则:一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。
    
    <img src="_media/hanoi-tower.png">

    
    
    * 算法分析
    
    当 A 柱子上只有一个盘子时，可以直接把盘子移到 C 柱子上;
    当 A 柱子上有两个盘子时，需要借助 B 盘子，先将上面的小盘子移到 B 柱子上，再将大盘子移到 C 柱子上，再将小盘子移到 C 柱子上。
    对于更一般的情况，当有 n 个盘子的时候怎么递归呢?当有 n 个盘子时，我们可以将盘子看成两个部分。第 n 个盘子和上面 n − 1 个盘子，
    如图中的颜色区分。就像是操作两个盘子(把前 n − 1 个盘子看成一个整体)：先把前 n − 1 个盘子从 A 盘放到 B 盘，再把第 n 个盘子从 A 盘放到 C 盘，
    最后再把前 n − 1 个 盘子从 B 盘放到 C 盘。这样我们就把问题的规模缩小到 n − 1 了。

    * 算法实现

  ```javascript
    class HanoiTower {
      constructor() {
        this.step = 0;       // 执行次数
      }
    
      /**
       *
       * @param n   盘子数
       * @param a   初始塔
       * @param b   中间塔
       * @param c   目的塔
       */
      hanoi(n, a, b, c) {
        if (n === 1) {
          // 递归的base case 只有一个盘子的时候，直接把盘子初始塔a塔移到目的塔c。
          this.move(1, a, c)
        } else {
          /**
           * 递归的一般情况：
           * 将 n 个盘子从初始塔a，移动到目的塔c只需要这样做：
           * 1.将前 n-1 个盘子从塔a，借助塔c，移动到塔b
           * 2.将第 n 个盘子从塔a移动到塔c
           * 3.将前 n-1 个盘子从塔b，借助塔a，移动到塔c
           */
          this.hanoi(n - 1, a, c, b);
          this.move(n, a, c);
          this.hanoi(n - 1, b, a, c);
        }
      }
    
      /**
       *
       * @param number  盘子编号
       * @param origin  移动前的塔
       * @param target  移动后的塔
       */
      move(number, origin, target) {
        console.log(`第${++this.step}次移动：${number}号盘子，${origin} -----> ${target}`);
      }
    }
    
    const hanoiTower = new HanoiTower();
    hanoiTower.hanoi(3, 'A', 'B', 'C');
    
    /**
     * 第1次移动：1号盘子，A -----> C
     * 第2次移动：2号盘子，A -----> B
     * 第3次移动：1号盘子，C -----> B
     * 第4次移动：3号盘子，A -----> C
     * 第5次移动：1号盘子，B -----> A
     * 第6次移动：2号盘子，B -----> C
     * 第7次移动：1号盘子，A -----> C
     **/
  ```

# 回溯与递归

##### 回溯算法

* 回溯与递归的区别和联系

很多人不理解回溯与递归到底是什么关系。其实很简单，**回溯**算法是一种**算法思想**，是我们解决问题的策略；
而**递归**是一种**算法结构**。递归就是函数调用本身，**一般回溯法多用递归来实现**。

* 回溯的基本思想

在按某种搜索策略搜索的过程中，当到达某一状态时，继续向前搜索已经确定不会得到正确答案的情况下，可以返回上一搜索状态，沿着新的可能性继续搜索。
其求解过程的实质是一个**先序遍历一棵'状态树'的过程**。

* 回溯的特点
    
    * **搜索策略**：符合递归算法，问题解决可以化为子问题，算法类似，规模减小;
    * **控制策略**：当遇到失败的搜索状态，需要返回上一状态，沿另外的路径搜索;
    * **数据结构**：一般用数组保存搜索过程中的状态、路径。

##### 回溯算法的经典例子

* 爬楼梯问题

对于一个由`n`级台阶组成的楼梯，爬楼梯时一次可以上`1`级台阶或`2`级台阶。共有多少种不同的走法。

**分析**：在任何一级台阶往上爬的时候都有两种选择：**爬 1 级台阶**或者**爬 2 级台阶**。
那就会产生回溯，当我们爬 2 级台阶会超出楼梯时，我们再返回来爬 1 级台阶;
其次，n 级台阶可能是由**第 n-1 级台阶爬上来**的，也可能是从**第 n-2 级台 阶爬上来**的。
那么，对于 n 级台阶的问题又可以分解成为两个相似的字问题。**符合递归的条件**。

```javascript
class ClimbingStairs {
  constructor() {
    this.count = 1;
    this.step = [];
  }

  tryStep(n) {
    for (let i = 1; i <= 2; i++) {
      if (n < i) {
        break;
      }
      n -= i;
      this.step[this.count++] = i;
      if (n === 0) {
        let str = '';
        for (let j = 1; j < this.count; j++) {
          str += `第${j}步走了${this.step[j]}级台阶 `;
        }
        console.log(str);
      } else {
        this.tryStep(n)
      }
      n += i;
      this.step[this.count--] = 0;
    }
  }
}

const climbingStairs = new ClimbingStairs();
climbingStairs.tryStep(4);
/**
 * 第1步走了1级台阶 第2步走了1级台阶 第3步走了1级台阶 第4步走了1级台阶
 * 第1步走了1级台阶 第2步走了1级台阶 第3步走了2级台阶
 * 第1步走了1级台阶 第2步走了2级台阶 第3步走了1级台阶
 * 第1步走了2级台阶 第2步走了1级台阶 第3步走了1级台阶
 * 第1步走了2级台阶 第2步走了2级台阶
 */
```
